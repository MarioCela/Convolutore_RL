#include<stdio.h>
#include<stdlib.h>
#include<time.h>

//description of these methods is down
void converter_integer_to_binary (int integer, bool *binary);
void convolutor_machine (int *state_pointer, bool *word_to_elaborate, bool *first_word_elaborated, bool *second_word_elaborated);
int converter_binary_to_integer(bool *binary);

int main()
{
	srand(time(NULL));
	//opening file where will be written words that will be elaborated by convolutor
	FILE *numbers_generated = fopen("test.txt", "w");
	//opening file where will be written convolution results
	FILE *convolution_result = fopen("convolution.txt", "w");

	//killing the program if opening does not go well
	if (numbers_generated == NULL)
	{
		printf("Problema in apertura file\n");
		exit(1);
	}
	if (convolution_result == NULL)
	{
		printf("Problema in apertura file\n");
		exit(1);
	}

	//creating number of words that will be elaborated
	int number_of_words_to_elaborate = 2;
	//rand() % 21;

	//printing it
	fprintf(numbers_generated, "%d\n", number_of_words_to_elaborate);

	//convolutor
	for (int i = 0; i < number_of_words_to_elaborate - 1; i++)
	{
		int index = 0;
		bool word_to_elaborate[8] = {0};
		bool first_word_elaborated[8] = {0};
		bool second_word_elaborated[8] = {0};

		//creating by random the word that has to be elaborated
		int number = rand() % 256;
		//converting it to binary
		converter_integer_to_binary(number, word_to_elaborate);

		//pointer to actual state in convolutor machine, as shown in the project's rules
		int state = 0;
		int *state_pointer;
		state_pointer = &state;

		//printing in binary actual word to elaborate
		printf("Word to elaborate: ");
		for (int i = 0; i < 8; i++)
        {
            printf("%d", word_to_elaborate[i]);
        }

        printf("\n");

		//generating output, that depends on convolutor's states that will be passed
		convolutor_machine(state_pointer, word_to_elaborate, first_word_elaborated, second_word_elaborated);

		//printing in binary first of two words in output generated by convolutor
		printf("First word elaborated: ");
		for (int i = 0; i < 8; i++)
        {
            printf("%d", first_word_elaborated[i]);
        }

        printf("\n");

		//printing in binary second of two words in output generated by convolutor
        printf("Second word elaborated: ");
		for (int i = 0; i < 8; i++)
        {
            printf("%d", second_word_elaborated[i]);
        }

        printf("\n\n");

		//converting two words in output into integer
		int first_binary = converter_binary_to_integer(first_word_elaborated);
		int second_binary = converter_binary_to_integer(second_word_elaborated);

		//writing on text files three words: words to elaborate, first in output and second in output
		fprintf(numbers_generated, "%d\n", number);
		fprintf(convolution_result, "%d\n", first_binary);
		fprintf(convolution_result, "%d\n", second_binary);
	}

		//doing the same thing for the last word expected. It has not been into the array to avoid a last \n\n in the txt file. It is so until line 136
		bool word_to_elaborate[8] = {0, 0, 0, 0, 0, 0, 0, 0};
		bool first_word_elaborated[8];
		bool second_word_elaborated[8];

		int number = rand() % 256;
		converter_integer_to_binary(number, word_to_elaborate);

		int state = 0;
		int *state_pointer = &state;

		printf("Word to elaborate: ");
		for (int i = 0; i < 8; i++)
        {
            printf("%d", word_to_elaborate[i]);
        }

        printf("\n");

		convolutor_machine(state_pointer, word_to_elaborate, first_word_elaborated, second_word_elaborated);

		printf("First word elaborated: ");
		for (int i = 0; i < 8; i++)
        {
            printf("%d", first_word_elaborated[i]);
        }

        printf("\n");

		printf("Second word elaborated: ");
		for (int i = 0; i < 8; i++)
        {
            printf("%d", second_word_elaborated[i]);
        }

        printf("\n\n");

		int first_binary = converter_binary_to_integer(first_word_elaborated);
		int second_binary = converter_binary_to_integer(second_word_elaborated);

		fprintf(numbers_generated, "%d", number);
		fprintf(convolution_result, "%d\n", first_binary);
		fprintf(convolution_result, "%d", second_binary);

	//closing two files
	fclose(numbers_generated);
	fclose(convolution_result);

	return 0;
}

//easy power function
int pow(int number, int exp)
{
	int result;

	if (exp == 0)
	{
		return 1;
	}
	else
	{
		return number * pow(number, exp - 1);
	}
}

//explicit name
void converter_integer_to_binary(int integer, bool *binary)
{
	int remainder;
	int integer_after_division_by_two = integer;
	int index = 7;

	while (integer != 0 && index >= 0)
	{
		integer_after_division_by_two = integer / 2;
		remainder = integer - integer_after_division_by_two * 2;
		integer = integer_after_division_by_two;
		binary[index] = remainder;
		index--;
	}

	return;
}

//still explicit, east to find out what it does
int converter_binary_to_integer(bool *binary)
{
	int number = 0;

	for (int i = 7; i >= 0; i--)
	{
		if(binary[i] == 1)
		{
			number += pow(2, i);
		}
	}

	return number;
}

//It does everything: gets the word to elaborate, starts from state 00 of the machine and begins its convolution, saving first 8 bits generated by
//first 4 bits of "word_to_elaborate" into the first word, the other ones to the second word
void convolutor_machine(int *state_pointer, bool *word_to_elaborate, bool *first_word_elaborated, bool *second_word_elaborated)
{
	//loop for first 4 bits of the word, that will generate the result that will be put into first_word_elaborated
	for (int i = 0; i < 4; i++)
	{
		//all the switch-case follows the FSA in the rules, defining next_state and 2 bits in output
		switch(*state_pointer)
		{
			case 0:
				if (word_to_elaborate[i] == 0)
				{
					first_word_elaborated[2*i] = 0;
					first_word_elaborated[2*i + 1] = 0;
				}
				else
				{
					first_word_elaborated[2*i] = 1;
					first_word_elaborated[2*i + 1] = 1;
					*state_pointer = 2;
				}
				break;
			case 1:
				if (word_to_elaborate[i] == 0)
				{
					first_word_elaborated[2*i] = 1;
					first_word_elaborated[2*i + 1] = 1;
					*state_pointer =  0;
				}
				else
				{
					first_word_elaborated[2*i] = 0;
					first_word_elaborated[2*i + 1] = 0;
					*state_pointer = 2;
				}
				break;
			case 2:
				if (word_to_elaborate[i] == 0)
				{
					first_word_elaborated[2*i] = 0;
					first_word_elaborated[2*i + 1] = 1;
					*state_pointer = 1;
				}
				else
				{
					first_word_elaborated[2*i] = 1;
					first_word_elaborated[2*i + 1] = 0;
					*state_pointer = 3;
				}
				break;
			case 3:
				if (word_to_elaborate[i] == 0)
				{
					first_word_elaborated[2*i] = 1;
					first_word_elaborated[2*i + 1] = 0;
					*state_pointer = 1;
				}
				else
				{
					first_word_elaborated[2*i] = 0;
					first_word_elaborated[2*i + 1] = 1;
				}
				break;
		}
	}

	//generates output that will be saved in second_word_elaborated. Notice that state_pointer is not initialized, it starts where first loop stopped, as it has to be
	for (int i = 0; i < 4; i++)
	{
		//still switch-case
        switch(*state_pointer)
		{
			case 0:
				if (word_to_elaborate[i + 4] == 0)
				{
					second_word_elaborated[2*i] = 0;
					second_word_elaborated[2*i + 1] = 0;
				}
				else
				{
					second_word_elaborated[2*i] = 1;
					second_word_elaborated[2*i + 1] = 1;
					*state_pointer = 2;
				}
				break;
			case 1:
				if (word_to_elaborate[i + 4] == 0)
				{
					second_word_elaborated[2*i] = 1;
					second_word_elaborated[2*i + 1] = 1;
					*state_pointer =  0;
				}
				else
				{
					second_word_elaborated[2*i] = 0;
					second_word_elaborated[2*i + 1] = 0;
					*state_pointer = 2;
				}
				break;
			case 2:
				if (word_to_elaborate[i + 4] == 0)
				{
					second_word_elaborated[2*i] = 0;
					second_word_elaborated[2*i + 1] = 1;
					*state_pointer = 1;
				}
				else
				{
					second_word_elaborated[2*i] = 1;
					second_word_elaborated[2*i + 1] = 0;
					*state_pointer = 3;
				}
				break;
			case 3:
				if (word_to_elaborate[i + 4] == 0)
				{
					second_word_elaborated[2*i] = 1;
					second_word_elaborated[2*i + 1] = 0;
					*state_pointer = 1;
				}
				else
				{
					second_word_elaborated[2*i] = 0;
					second_word_elaborated[2*i + 1] = 1;
				}
				break;
		}
	}
}
